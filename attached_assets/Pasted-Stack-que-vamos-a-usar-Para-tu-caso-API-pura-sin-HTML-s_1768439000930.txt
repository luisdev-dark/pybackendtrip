Stack que vamos a usar

Para tu caso (API pura, sin HTML, startup, TypeScript en el front) lo más adecuado es:

FastAPI → framework rápido para APIs (tipo Express pero tipado)

Uvicorn → servidor ASGI

SQLAlchemy 2.x (async) → ORM para Postgres

asyncpg → driver Postgres asincrónico

Alembic → migraciones (opcional pero recomendado)

Pydantic → modelos de entrada/salida (ya viene con FastAPI)

Puedes desplegar esto luego en:

Render, Railway, Fly, etc. (cuando toque deploy)

2️⃣ Estructura de proyecto recomendada

Digamos que tu backend vive en una carpeta backend_py/:

backend_py/
├── app/
│   ├── __init__.py
│   ├── main.py              # Punto de entrada FastAPI
│   ├── core/
│   │   ├── config.py        # Configuración (env vars, Neon URL, etc.)
│   │   └── db.py            # Conexión a DB (SQLAlchemy async)
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py          # Base del ORM (Declarative Base)
│   │   ├── user.py          # Modelo User
│   │   ├── route.py         # Modelo Route + RouteStop
│   │   └── trip.py          # Modelo Trip
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── user.py          # Pydantic para respuestas/inputs
│   │   ├── route.py
│   │   └── trip.py
│   ├── api/
│   │   ├── __init__.py
│   │   ├── deps.py          # Dependencias comunes (get_db, etc.)
│   │   └── routes/
│   │       ├── __init__.py
│   │       ├── health.py    # /health
│   │       ├── routes.py    # /routes y /routes/{id}
│   │       └── trips.py     # /trips y /trips/{id}
│   └── services/
│       ├── __init__.py
│       └── pricing.py       # lógica de precio (si la necesitas luego)
├── alembic/                 # (opcional) Migraciones automáticas
│   └── ...                  
├── alembic.ini              # Config Alembic
├── sql/
│   ├── schema.sql           # Tu esquema en SQL puro (opcional, ya lo tienes)
│   └── seed.sql             # Datos de prueba (UUID fijos)
├── requirements.txt         # Dependencias Python
└── README.md                # Cómo correr el backend


Si ya tienes schema.sql y seed.sql de Neon (del proyecto Go), los puedes reutilizar tal cual. Solo tienes que hacer que los modelos de SQLAlchemy reflejen esas tablas.

3️⃣ Contenido de los archivos importantes (qué va en cada uno)
requirements.txt

Algo así:

fastapi
uvicorn[standard]
SQLAlchemy>=2.0
asyncpg
alembic
python-dotenv
pydantic

app/main.py – arranque de FastAPI
from fastapi import FastAPI
from app.api.routes import health, routes, trips

app = FastAPI(
    title="RealGo MVP",
    version="0.1.0",
)

# Incluir routers
app.include_router(health.router, prefix="/health", tags=["health"])
app.include_router(routes.router, prefix="/routes", tags=["routes"])
app.include_router(trips.router, prefix="/trips", tags=["trips"])

# Así tu frontend hablará con:
# GET /health
# GET /routes
# GET /routes/{id}
# POST /trips
# GET /trips/{id}

app/core/config.py – configuración (Neon, etc.)
import os
from pydantic import BaseSettings, AnyUrl

class Settings(BaseSettings):
    DATABASE_URL: AnyUrl

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()


.env (en la raíz del backend):

DATABASE_URL=postgresql+asyncpg://user:password@ep-xxx.region.neon.tech/dbname?sslmode=require


Ojo: para SQLAlchemy async, la URL suele ser postgresql+asyncpg://...

app/core/db.py – conexión async a Neon
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine, async_sessionmaker, AsyncSession
from app.core.config import settings

engine: AsyncEngine = create_async_engine(
    settings.DATABASE_URL,
    echo=False,
    pool_pre_ping=True,
)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    expire_on_commit=False,
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session

app/models/base.py – base del ORM
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

app/models/user.py (ejemplo de modelo)
from sqlalchemy import Column, String, Boolean, Enum
from sqlalchemy.dialects.postgresql import UUID
import uuid
from app.models.base import Base
import enum

class UserRole(str, enum.Enum):
    passenger = "passenger"
    driver = "driver"
    admin = "admin"

class User(Base):
    __tablename__ = "users"
    __table_args__ = {"schema": "app"}  # porque usas schema app

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    role = Column(Enum(UserRole, name="user_role"), nullable=False, default=UserRole.passenger)
    full_name = Column(String, nullable=False)
    phone_e164 = Column(String, nullable=False, unique=True)
    is_active = Column(Boolean, nullable=False, default=True)

app/models/route.py – routes y stops
from sqlalchemy import Column, String, Boolean, Integer, Float, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
from app.models.base import Base

class Route(Base):
    __tablename__ = "routes"
    __table_args__ = {"schema": "app"}

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    origin_name = Column(String, nullable=False)
    origin_lat = Column(Float, nullable=False)
    origin_lon = Column(Float, nullable=False)
    destination_name = Column(String, nullable=False)
    destination_lat = Column(Float, nullable=False)
    destination_lon = Column(Float, nullable=False)
    base_price_cents = Column(Integer, nullable=False, default=0)
    currency = Column(String(3), nullable=False, default="PEN")
    is_active = Column(Boolean, nullable=False, default=True)

    stops = relationship("RouteStop", back_populates="route", order_by="RouteStop.stop_order")


class RouteStop(Base):
    __tablename__ = "route_stops"
    __table_args__ = {"schema": "app"}

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    route_id = Column(UUID(as_uuid=True), ForeignKey("app.routes.id"), nullable=False)
    stop_order = Column(Integer, nullable=False)
    name = Column(String, nullable=False)
    lat = Column(Float, nullable=False)
    lon = Column(Float, nullable=False)
    is_active = Column(Boolean, nullable=False, default=True)

    route = relationship("Route", back_populates="stops")

app/models/trip.py – trips
from sqlalchemy import Column, String, Integer, Enum, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum
from app.models.base import Base

class TripStatus(str, enum.Enum):
    requested = "requested"
    confirmed = "confirmed"
    started = "started"
    finished = "finished"
    cancelled = "cancelled"

class PaymentMethod(str, enum.Enum):
    cash = "cash"
    yape = "yape"
    plin = "plin"

class Trip(Base):
    __tablename__ = "trips"
    __table_args__ = {"schema": "app"}

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    route_id = Column(UUID(as_uuid=True), ForeignKey("app.routes.id"), nullable=False)
    passenger_id = Column(UUID(as_uuid=True), ForeignKey("app.users.id"), nullable=False)
    pickup_stop_id = Column(UUID(as_uuid=True), ForeignKey("app.route_stops.id"), nullable=True)
    dropoff_stop_id = Column(UUID(as_uuid=True), ForeignKey("app.route_stops.id"), nullable=True)

    status = Column(Enum(TripStatus, name="trip_status"), nullable=False, default=TripStatus.requested)
    payment_method = Column(Enum(PaymentMethod, name="payment_method"), nullable=False, default=PaymentMethod.cash)
    price_cents = Column(Integer, nullable=False, default=0)
    currency = Column(String(3), nullable=False, default="PEN")

app/schemas/route.py – Pydantic para respuesta
from pydantic import BaseModel
from typing import List, Optional

class RouteSummary(BaseModel):
    id: str
    name: str
    origin_name: str
    destination_name: str
    base_price_cents: int
    currency: str

    class Config:
        from_attributes = True


class RouteStopOut(BaseModel):
    id: str
    name: str
    stop_order: int

    class Config:
        from_attributes = True


class RouteDetail(BaseModel):
    route: RouteSummary
    stops: List[RouteStopOut]

app/schemas/trip.py
from pydantic import BaseModel
from typing import Optional, Literal

class TripCreate(BaseModel):
    route_id: str
    pickup_stop_id: Optional[str] = None
    dropoff_stop_id: Optional[str] = None
    payment_method: Literal["cash", "yape", "plin"]


class TripOut(BaseModel):
    id: str
    route_id: str
    passenger_id: str
    pickup_stop_id: Optional[str]
    dropoff_stop_id: Optional[str]
    status: str
    payment_method: str
    price_cents: int
    currency: str

    class Config:
        from_attributes = True

app/api/deps.py – dependencia DB
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.db import get_db

async def get_db_session() -> AsyncGenerator[AsyncSession, None]:
    async for session in get_db():
        yield session

app/api/routes/health.py
from fastapi import APIRouter

router = APIRouter()

@router.get("", summary="Health check")
async def health():
    return {"status": "ok", "service": "realgo-mvp"}

app/api/routes/routes.py – endpoints de rutas
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List
from app.api.deps import get_db_session
from app.models.route import Route, RouteStop
from app.schemas.route import RouteSummary, RouteDetail, RouteStopOut

router = APIRouter()

@router.get("", response_model=List[RouteSummary])
async def list_routes(db: AsyncSession = Depends(get_db_session)):
    stmt = select(Route).where(Route.is_active == True)
    result = await db.execute(stmt)
    routes = result.scalars().all()
    return routes

@router.get("/{route_id}", response_model=RouteDetail)
async def get_route_detail(route_id: str, db: AsyncSession = Depends(get_db_session)):
    # podrías validar UUID aquí si quieres
    route_stmt = select(Route).where(Route.id == route_id)
    route_result = await db.execute(route_stmt)
    route = route_result.scalar_one_or_none()
    if not route:
        raise HTTPException(status_code=404, detail="Route not found")

    stops_stmt = (
        select(RouteStop)
        .where(RouteStop.route_id == route_id, RouteStop.is_active == True)
        .order_by(RouteStop.stop_order)
    )
    stops_result = await db.execute(stops_stmt)
    stops = stops_result.scalars().all()

    return RouteDetail(
        route=route,
        stops=stops,
    )

app/api/routes/trips.py – endpoints de trips (MVP)
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.api.deps import get_db_session
from app.models.trip import Trip, TripStatus, PaymentMethod
from app.schemas.trip import TripCreate, TripOut

router = APIRouter()

HARDCODED_PASSENGER_ID = "11111111-1111-1111-1111-111111111111"

@router.post("", response_model=TripOut)
async def create_trip(payload: TripCreate, db: AsyncSession = Depends(get_db_session)):
    if payload.pickup_stop_id and payload.dropoff_stop_id and payload.pickup_stop_id == payload.dropoff_stop_id:
        raise HTTPException(status_code=400, detail="pickup_stop_id and dropoff_stop_id must be different")

    trip = Trip(
        route_id=payload.route_id,
        passenger_id=HARDCODED_PASSENGER_ID,
        pickup_stop_id=payload.pickup_stop_id,
        dropoff_stop_id=payload.dropoff_stop_id,
        status=TripStatus.requested,
        payment_method=PaymentMethod(payload.payment_method),
        # precio fijo por ahora: podrías cargarlo desde Route en otra consulta
    )

    db.add(trip)
    await db.commit()
    await db.refresh(trip)
    return trip

@router.get("/{trip_id}", response_model=TripOut)
async def get_trip(trip_id: str, db: AsyncSession = Depends(get_db_session)):
    stmt = select(Trip).where(Trip.id == trip_id)
    result = await db.execute(stmt)
    trip = result.scalar_one_or_none()
    if not trip:
        raise HTTPException(status_code=404, detail="Trip not found")
    return trip
